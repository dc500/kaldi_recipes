#!/bin/bash

# lang4diffstates.sh
# Instead of dividing the language models into 2 simple phonesets: nonsilence and silence,
# this script sets the different phonesets with the different number of HMM states
# based on the given phoneset information from the user.
# ex. vowel = 3 states, stop = 2 states, non-stop = 1 states.

# if [ $# -ne 5 ]; then
#    echo "Wrong option arguments. Please provide 5 arguments" && exit 1
# fi
# srcdir=$1
# oov_word=$2
# tmpdir=$3
# dir=$4
# # data directory contains non silence phoneset text files.
# data_dir=$5
curdir=$PWD
srcdir=$curdir/data/local/dict
oov_word="<UNK>"
tmpdir=$curdir/data/local/lang
dir=$curdir/data/lang
data_dir=$curdir/phonesets


# phoneset number
phone_file=`ls $data_dir`
set_num=`cat $data_dir/$phone_file | awk '{print $1}' | wc -l`
# phoneset name
for n in `seq $set_num`; do
	eval phone_$n=`cat $data_dir/$phone_file | sed ${n}'!d' | awk '{print $1}'`
done
# phoneset list
for l in `seq $set_num`; do
	tmp_name=$(eval echo \$phone_$l)
	eval list_$l=$tmp_name
	cat $data_dir/$phone_file | sed ${l}'!d' | cut -d ' ' -f3- | tr ' ' '\n' > $srcdir/$tmp_name.txt
done
# phoneset state
for s in `seq $set_num`; do
	eval state_$s=`cat $data_dir/$phone_file | sed ${s}'!d' | awk '{print $2}'`
done

# check arguments.
for ch in `seq $set_num`; do
	eval echo "phone name: \$phone_${ch}, phone state: \$state_${ch}"
done


num_word_disambig_syms=1
position_dependent_phones=true
# position_dependent_phones is false also when position dependent phones and word_boundary.txt
# have been generated by another source
reverse=false
share_silence_phones=false  # if true, then share pdfs of different silence
                            # phones together.
sil_prob=0.5
phone_symbol_table=              # if set, use a specified phones.txt file.
# end configuration sections

. utils/parse_options.sh

mkdir -p $dir $tmpdir $dir/phones

silprob=false
[ -f $srcdir/lexiconp_silprob.txt ] && silprob=true

[ -f path.sh ] && . ./path.sh


if $position_dependent_phones; then
  # Create $tmpdir/lexicon.original from $srcdir/lexicon.txt by
  # adding the markers _B, _E, _S, _I depending on word position.
  # In this recipe, these markers apply to silence also.
  # Do this starting from lexiconp.txt only.
  if "$silprob"; then
    perl -ane '@A=split(" ",$_); $w = shift @A; $p = shift @A; $silword_p = shift @A;
              $wordsil_f = shift @A; $wordnonsil_f = shift @A; @A>0||die;
         if(@A==1) { print "$w $p $silword_p $wordsil_f $wordnonsil_f $A[0]_S\n"; }
         else { print "$w $p $silword_p $wordsil_f $wordnonsil_f $A[0]_B ";
         for($n=1;$n<@A-1;$n++) { print "$A[$n]_I "; } print "$A[$n]_E\n"; } ' \
                < $srcdir/lexiconp_silprob.txt > $tmpdir/lexiconp_silprob.txt
    if $reverse; then
      echo "We do not support reverse option and silprob at the same time"
      exit 1
    fi
  else
    perl -ane '@A=split(" ",$_); $w = shift @A; $p = shift @A; @A>0||die;
         if(@A==1) { print "$w $p $A[0]_S\n"; } else { print "$w $p $A[0]_B ";
         for($n=1;$n<@A-1;$n++) { print "$A[$n]_I "; } print "$A[$n]_E\n"; } ' \
           < $srcdir/lexiconp.txt > $tmpdir/lexiconp.pre_reverse || exit 1;
    if $reverse; then
      echo "reversing lexicon."
      cat $tmpdir/lexiconp.pre_reverse \
        | awk '{printf "%s %s ",$1, $2;for(i=NF;i>2;i--){printf "%s ",$i;}printf "\n"}' \
        > $tmpdir/lexiconp.txt
    else
      mv $tmpdir/lexiconp.pre_reverse $tmpdir/lexiconp.txt
    fi
  fi
fi

  # create $tmpdir/phone_map.txt
  # this has the format (on each line)
  # <original phone> <version 1 of original phone> <version 2> ...
  # where the versions depend on the position of the phone within a word.
  # For instance, we'd have:
  # AA AA_B AA_E AA_I AA_S
  # for (B)egin, (E)nd, (I)nternal and (S)ingleton
  # and in the case of silence
  # SIL SIL SIL_B SIL_E SIL_I SIL_S
  # [because SIL on its own is one of the variants; this is for when it doesn't
  #  occur inside a word but as an option in the lexicon.]

  # This phone map expands the phone lists into all the word-position-dependent
  # versions of the phone lists.

for p in `seq $set_num`; do
	if [ $p -eq 1 ]; then
  		set -f; for x in $(cat $srcdir/$list_1.txt); do for y in "" "" "_B" "_E" "_I" "_S"; do echo -n "$x$y "; done; echo; done > $tmpdir/phone_map.txt
  	elif [ $p -ne 1 ]; then
    	set -f; for x in $(eval cat $srcdir/\$list_$p.txt); do for y in "" "_B" "_E" "_I" "_S"; do echo -n "$x$y "; done; echo; done >> $tmpdir/phone_map.txt
    elif [ $p -eq $set_num ]; then
    	set -f; for x in $(eval cat $srcdir/\$list_$p.txt); do for y in "" "_B" "_E" "_I" "_S"; do echo -n "$x$y "; done; echo; done >> $tmpdir/phone_map.txt
  fi
done

mkdir -p $dir/phones  # various sets of phones...

# Sets of phones for use in clustering, and making monophone systems.


# different silence phones will have different GMMs.  [note: here, all "shared split" means
# is that we may have one GMM for all the states, or we can split on states.  because they're
# context-independent phones, they don't see the context.]
for l in `seq $set_num`; do eval cat $srcdir/\$list_$l.txt; done | utils/apply_map.pl $tmpdir/phone_map.txt > $dir/phones/sets.txt
cat $dir/phones/sets.txt | awk '{print "shared", "split", $0;}' > $dir/phones/roots.txt

for pm in `seq $set_num`; do
	tmp_name=$(eval echo \$phone_$pm)
	eval cat $srcdir/\$list_$pm.txt | utils/apply_map.pl $tmpdir/phone_map.txt | \
  		awk '{for(n=1;n<=NF;n++) print $n;}' > $dir/phones/$tmp_name.txt
done
cp $srcdir/optional_silence.txt $dir/phones/optional_silence.txt
sil_name=`echo $phone_1`
cp $dir/phones/$sil_name.txt $dir/phones/context_indep.txt

# if extra_questions.txt is empty, it's OK.
cat $srcdir/extra_questions.txt 2>/dev/null | utils/apply_map.pl $tmpdir/phone_map.txt \
  >$dir/phones/extra_questions.txt

# Want extra questions about the word-start/word-end stuff. Make it separate for
# silence and non-silence. Probably doesn't matter, as silence will rarely
# be inside a word.
if $position_dependent_phones; then
	for ex in `seq $set_num 1`; do
		if [ $ex -eq 1 ]; then
			for suffix in "" _B _E _I _S; do
    			(set -f; for x in `cat $srcdir/$list_1.txt`; do echo -n "$x$suffix "; done; echo) >> $dir/phones/extra_questions.txt
  		done
  	elif [ $ex -gt 1 ]; then
  		for suffix in _B _E _I _S; do
    			(set -f; for x in $(eval cat $srcdir/\$list_$ex.txt); do echo -n "$x$suffix "; done; echo) >> $dir/phones/extra_questions.txt
      done	
    fi
  done
fi

# add disambig symbols to the lexicon in $tmpdir/lexiconp.txt
# and produce $tmpdir/lexicon_*disambig.txt

if "$silprob"; then
  ndisambig=`utils/add_lex_disambig.pl --pron-probs --sil-probs $tmpdir/lexiconp_silprob.txt $tmpdir/lexiconp_silprob_disambig.txt`
else
  ndisambig=`utils/add_lex_disambig.pl --pron-probs $tmpdir/lexiconp.txt $tmpdir/lexiconp_disambig.txt`
fi
ndisambig=$[$ndisambig+1]; # add one disambig symbol for silence in lexicon FST.
echo $ndisambig > $tmpdir/lex_ndisambig

# Format of lexiconp_disambig.txt:
# !SIL	1.0   SIL_S
# <SPOKEN_NOISE>	1.0   SPN_S #1
# <UNK>	1.0  SPN_S #2
# <NOISE>	1.0  NSN_S
# !EXCLAMATION-POINT	1.0  EH2_B K_I S_I K_I L_I AH0_I M_I EY1_I SH_I AH0_I N_I P_I OY2_I N_I T_E

( for n in `seq 0 $ndisambig`; do echo '#'$n; done ) >$dir/phones/disambig.txt

# Create phone symbol table.
if [[ ! -z $phone_symbol_table ]]; then
  start_symbol=`grep \#0 $phone_symbol_table | awk '{print $2}'`
  echo "<eps>" | cat - $(for tl in `seq $set_num`; do eval echo "$dir/phones/\$list_$tl.txt";done) | awk -v f=$phone_symbol_table '
  BEGIN { while ((getline < f) > 0) { phones[$1] = $2; }} { print $1" "phones[$1]; }' | sort -k2 -g |\
    cat - <(cat $dir/phones/disambig.txt | awk -v x=$start_symbol '{n=x+NR-1; print $1, n;}') > $dir/phones.txt
else
  echo "<eps>" | cat - $(for tl in `seq $set_num`; do eval echo "$dir/phones/\$list_$tl.txt";done) | \
  cat - $dir/phones/disambig.txt | awk '{n=NR-1; print $1, n;}' > $dir/phones.txt
fi

# Create a file that describes the word-boundary information for
# each phone.  5 categories.
if $position_dependent_phones; then
  cat $(for i in `seq $set_num`; do eval echo $dir/phones/\$list_$i.txt; done) | \
    awk '/_I$/{print $1, "internal"; next;} /_B$/{print $1, "begin"; next; }
         /_S$/{print $1, "singleton"; next;} /_E$/{print $1, "end"; next; }
         {print $1, "nonword";} ' > $dir/phones/word_boundary.txt
else
  # word_boundary.txt might have been generated by another source
  [ -f $srcdir/word_boundary.txt ] && cp $srcdir/word_boundary.txt $dir/phones/word_boundary.txt
fi

# Create word symbol table.
# <s> and </s> are only needed due to the need to rescore lattices with
# ConstArpaLm format language model. They do not normally appear in G.fst or
# L.fst.

if "$silprob"; then
  # remove the silprob
  cat $tmpdir/lexiconp_silprob.txt |\
    awk '{
      for(i=1; i<=NF; i++) {
        if(i!=3 && i!=4 && i!=5) printf("%s\t", $i); if(i==NF) print "";
      }
    }' > $tmpdir/lexiconp.txt
fi

cat $tmpdir/lexiconp.txt | awk '{print $1}' | sort | uniq  | awk '
  BEGIN {
    print "<eps> 0";
  }
  {
    if ($1 == "<s>") {
      print "<s> is in the vocabulary!" | "cat 1>&2"
      exit 1;
    }
    if ($1 == "</s>") {
      print "</s> is in the vocabulary!" | "cat 1>&2"
      exit 1;
    }
    printf("%s %d\n", $1, NR);
  }
  END {
    printf("#0 %d\n", NR+1);
    printf("<s> %d\n", NR+2);
    printf("</s> %d\n", NR+3);
  }' > $dir/words.txt || exit 1;

# format of $dir/words.txt:
#<eps> 0
#!EXCLAMATION-POINT 1
#!SIL 2
#"CLOSE-QUOTE 3
#...

silphone=`cat $srcdir/optional_silence.txt` || exit 1;
[ -z "$silphone" ] && \
  ( echo "You have no optional-silence phone; it is required in the current scripts"
    echo "but you may use the option --sil-prob 0.0 to stop it being used." ) && \
   exit 1;

# create $dir/phones/align_lexicon.{txt,int}.
# This is the new-new style of lexicon aligning.

# First remove pron-probs from the lexicon.
perl -ape 's/(\S+\s+)\S+\s+(.+)/$1$2/;' <$tmpdir/lexiconp.txt >$tmpdir/align_lexicon.txt

# Note: here, $silphone will have no suffix e.g. _S because it occurs as optional-silence,
# and is not part of a word.
[ ! -z "$silphone" ] && echo "<eps> $silphone" >> $tmpdir/align_lexicon.txt

cat $tmpdir/align_lexicon.txt | \
 perl -ane '@A = split; print $A[0], " ", join(" ", @A), "\n";' | sort | uniq > $dir/phones/align_lexicon.txt

# create phones/align_lexicon.int
cat $dir/phones/align_lexicon.txt | utils/sym2int.pl -f 3- $dir/phones.txt | \
  utils/sym2int.pl -f 1-2 $dir/words.txt > $dir/phones/align_lexicon.int

# Create the basic L.fst without disambiguation symbols, for use
# in training.

if $silprob; then
  # Usually it's the same as having a fixed-prob L.fst
  # it matters a little bit in discriminative trainings
  utils/make_lexicon_fst_silprob.pl $tmpdir/lexiconp_silprob_disambig.txt $srcdir/silprob.txt $silphone '#'$ndisambig | \
     sed 's=\#[0-9][0-9]*=<eps>=g' | \
     fstcompile --isymbols=$dir/phones.txt --osymbols=$dir/words.txt \
     --keep_isymbols=false --keep_osymbols=false |   \
     fstarcsort --sort_type=olabel > $dir/L.fst || exit 1;
else
  utils/make_lexicon_fst.pl --pron-probs $tmpdir/lexiconp.txt $sil_prob $silphone | \
    fstcompile --isymbols=$dir/phones.txt --osymbols=$dir/words.txt \
    --keep_isymbols=false --keep_osymbols=false | \
     fstarcsort --sort_type=olabel > $dir/L.fst || exit 1;
fi

# The file oov.txt contains a word that we will map any OOVs to during
# training.
echo "$oov_word" > $dir/oov.txt || exit 1;
cat $dir/oov.txt | utils/sym2int.pl $dir/words.txt >$dir/oov.int || exit 1;
# integer version of oov symbol, used in some scripts.


# the file wdisambig.txt contains a (line-by-line) list of the text-form of the
# disambiguation symbols that are used in the grammar and passed through by the
# lexicon.  At this stage it's hardcoded as '#0', but we're laying the groundwork
# for more generality (which probably would be added by another script).
# wdisambig_words.int contains the corresponding list interpreted by the
# symbol table words.txt, and wdisambig_phones.int contains the corresponding
# list interpreted by the symbol table phones.txt.
echo '#0' >$dir/phones/wdisambig.txt
utils/sym2int.pl $dir/phones.txt <$dir/phones/wdisambig.txt >$dir/phones/wdisambig_phones.int
utils/sym2int.pl $dir/words.txt <$dir/phones/wdisambig.txt >$dir/phones/wdisambig_words.int
# Create these lists of phones in colon-separated integer list form too,
# for purposes of being given to programs as command-line options.
for f in `seq $set_num`; do
	tmp_name=$(eval echo \$list_$f)
  	utils/sym2int.pl $dir/phones.txt < $dir/phones/$tmp_name.txt > $dir/phones/$tmp_name.int
  	utils/sym2int.pl $dir/phones.txt < $dir/phones/$tmp_name.txt | \
    awk '{printf(":%d", $1);} END{printf "\n"}' | sed s/:// > $dir/phones/$tmp_name.csl || exit 1;
done

for f in optional_silence disambig context_indep; do
  utils/sym2int.pl $dir/phones.txt <$dir/phones/$f.txt >$dir/phones/$f.int
  utils/sym2int.pl $dir/phones.txt <$dir/phones/$f.txt | \
   awk '{printf(":%d", $1);} END{printf "\n"}' | sed s/:// > $dir/phones/$f.csl || exit 1;
done

for x in sets extra_questions; do
  utils/sym2int.pl $dir/phones.txt <$dir/phones/$x.txt > $dir/phones/$x.int || exit 1;
done

utils/sym2int.pl -f 3- $dir/phones.txt <$dir/phones/roots.txt \
   > $dir/phones/roots.int || exit 1;

#if $position_dependent_phones; then
if [ -f $dir/phones/word_boundary.txt ]; then
  utils/sym2int.pl -f 1 $dir/phones.txt <$dir/phones/word_boundary.txt \
    > $dir/phones/word_boundary.int || exit 1;
fi

str=
for pin in `seq $set_num`; do
	now_phone=$(eval cat $dir/phones/\$phone_$pin.csl)
	now_state=$(eval echo \$state_$pin)
	str+=" $now_phone $now_state"
done
python3 local/gen_topo4diffstates.py $str > $dir/topo

#utils/gen_topo_4phonesets.pl $num_sil_states $num_vowel_states $num_stop_states $num_nonstop_states $silphonelist $vowellist $stoplist $nonstoplist > $dir/topo

# Create the lexicon FST with disambiguation symbols, and put it in lang_test.
# There is an extra step where we create a loop to "pass through" the
# disambiguation symbols from G.fst.

if $silprob; then
  utils/make_lexicon_fst_silprob.pl $tmpdir/lexiconp_silprob_disambig.txt $srcdir/silprob.txt $silphone '#'$ndisambig | \
     fstcompile --isymbols=$dir/phones.txt --osymbols=$dir/words.txt \
     --keep_isymbols=false --keep_osymbols=false |   \
     fstaddselfloops  $dir/phones/wdisambig_phones.int $dir/phones/wdisambig_words.int | \
     fstarcsort --sort_type=olabel > $dir/L_disambig.fst || exit 1;
else
  utils/make_lexicon_fst.pl --pron-probs $tmpdir/lexiconp_disambig.txt $sil_prob $silphone '#'$ndisambig | \
     fstcompile --isymbols=$dir/phones.txt --osymbols=$dir/words.txt \
     --keep_isymbols=false --keep_osymbols=false |   \
     fstaddselfloops  $dir/phones/wdisambig_phones.int $dir/phones/wdisambig_words.int | \
     fstarcsort --sort_type=olabel > $dir/L_disambig.fst || exit 1;
fi

exit 0;
